<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Root-Finding Methods Explorer - Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/12.4.2/math.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <style>
        :root {
            --primary: #0f766e;
            --primary-light: #10b981;
            --bg-light: #f7faf9;
            --accent-amber: #f59e0b;
            --accent-red: #dc2626;
            --text-dark: #212121;
            --text-muted: #4b5563;
            --border-light: #e5e7eb;
            --interactive-bg: #e6fffb;
            
            /* Method colors */
            --bisection-color: #f59e0b;
            --false-pos-color: #dc2626;
            --secant-color: #8b5cf6;
            --newton-color: #10b981;
            --fixed-point-color: #3b82f6;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-light);
            color: var(--text-dark);
            line-height: 1.6;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 1rem;
        }
        
        .main-header {
            text-align: center;
            margin-bottom: 2rem;
        }
        
        h1 {
            font-size: 2rem;
            color: var(--primary);
            margin: 1rem 0 0.5rem;
        }
        
        .subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }
        
        /* Mathswell Nav */
        .mathswell-nav {
            display: flex;
            justify-content: center;
            margin: 0.75rem 0 1rem;
        }
        
        .mathswell-nav a {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            font-weight: 800;
            font-size: 1.05rem;
            color: var(--primary);
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            background: white;
            box-shadow: 0 1px 4px rgba(0,0,0,0.08);
            transition: transform 0.2s;
        }
        
        .mathswell-nav a:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.12);
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            background: white;
            padding: 0.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        
        .tab-button {
            flex: 1;
            padding: 0.75rem 1rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s;
        }
        
        .tab-button:hover {
            background: var(--bg-light);
        }
        
        .tab-button.active {
            background: var(--primary);
            color: white;
            font-weight: 600;
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Cards and Sections */
        .section {
            background: white;
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 16px rgba(0,0,0,0.06);
        }
        
        h2 {
            font-size: 1.5rem;
            color: var(--primary);
            margin-bottom: 1rem;
        }
        
        h3 {
            font-size: 1.2rem;
            color: var(--text-dark);
            margin-top: 1.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-light);
        }
        
        /* Introduction Elements */
        .concept-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }
        
        .concept-card {
            background: var(--bg-light);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 1.25rem;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .concept-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .concept-card h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .concept-card p {
            color: var(--text-muted);
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .interactive-demo {
            background: var(--interactive-bg);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
        }
        
        .demo-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .demo-control {
            flex: 1;
            min-width: 200px;
        }
        
        .demo-control label {
            display: block;
            color: var(--text-muted);
            font-size: 0.9rem;
            margin-bottom: 0.25rem;
            font-weight: 500;
        }
        
        .demo-control input, .demo-control select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.2s;
        }
        
        .demo-control input:focus, .demo-control select:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1rem;
            margin: 1.5rem 0;
        }
        
        .insight-card {
            background: white;
            border-left: 4px solid var(--primary);
            padding: 1rem 1.25rem;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }
        
        .insight-card h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .nav-buttons {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            flex-wrap: wrap;
        }
        
        .nav-button {
            flex: 1;
            min-width: 200px;
            padding: 1rem;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .nav-button:hover {
            background: var(--primary-light);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(15, 118, 110, 0.3);
        }
        
        /* Example Cards */
        .example-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .example-card {
            padding: 1rem;
            background: white;
            border: 2px solid var(--border-light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        
        .example-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .example-card.active {
            background: var(--interactive-bg);
            border-color: var(--primary);
        }
        
        .example-card .category {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }
        
        .example-card .formula {
            font-size: 1.1rem;
            color: var(--text-dark);
            margin: 0.5rem 0;
        }
        
        /* Function Display */
        .math-display {
            background: white;
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1.5rem;
            text-align: center;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .math-display .katex {
            font-size: 1.2rem;
        }
        
        .function-preview {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .function-card {
            background: var(--interactive-bg);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            text-align: center;
        }
        
        .function-card .label {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }
        
        #function-graph, #examples-graph, #demo-canvas {
            width: 100%;
            height: 250px;
            border-radius: 8px;
            background: white;
            border: 1px solid var(--border-light);
            margin-bottom: 1.5rem;
        }
        
        /* Control Grid */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .control-group label {
            font-size: 0.9rem;
            color: var(--text-muted);
            font-weight: 500;
        }
        
        .control-group input, .control-group textarea {
            padding: 0.6rem;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            font-family: monospace;
            font-size: 0.95rem;
            transition: border-color 0.2s;
        }
        
        .control-group input:focus, .control-group textarea:focus {
            outline: none;
            border-color: var(--primary);
        }
        
        .run-button {
            grid-column: span 2;
            padding: 0.75rem 1.5rem;
            background: var(--primary-light);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .run-button:hover {
            background: var(--primary);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }
        
        /* AI Assistance */
        .ai-assistant {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border: 1px solid #0ea5e9;
            border-radius: 8px;
            padding: 1rem;
            margin: 1.5rem 0;
        }
        
        .ai-hint {
            display: flex;
            gap: 0.75rem;
            align-items: start;
            margin-bottom: 0.75rem;
        }
        
        .ai-icon {
            font-size: 1.5rem;
            line-height: 1;
        }
        
        .ai-message {
            flex: 1;
            color: var(--text-dark);
            font-size: 0.95rem;
            line-height: 1.5;
        }
        
        .ai-button {
            padding: 0.5rem 1rem;
            background: #0ea5e9;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }
        
        .ai-button:hover {
            background: #0284c7;
            transform: translateY(-1px);
        }
        
        /* Results */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }
        
        .result-card {
            background: var(--bg-light);
            border-radius: 8px;
            padding: 1.25rem;
            text-align: center;
            border: 1px solid var(--border-light);
            transition: transform 0.2s;
        }
        
        .result-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .result-card h4 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
        }
        
        .result-card .value {
            font-size: 1.3rem;
            font-weight: bold;
            font-family: monospace;
            margin: 0.5rem 0;
        }
        
        .result-card .status {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .status.converged { color: var(--primary-light); }
        .status.failed { color: var(--accent-red); }
        
        h4.bisection { color: var(--bisection-color); }
        h4.false-pos { color: var(--false-pos-color); }
        h4.secant { color: var(--secant-color); }
        h4.newton { color: var(--newton-color); }
        h4.fixed-point { color: var(--fixed-point-color); }
        
        #plot-container, #examples-plot-container {
            position: relative;
            height: 400px;
            background: white;
            border-radius: 8px;
            padding: 1rem;
        }
        
        #plot-container p, #examples-plot-container p {
            text-align: center;
            color: var(--text-muted);
            font-style: italic;
            padding: 3rem;
        }
        
        /* Learning Points */
        .learning-points {
            background: var(--bg-light);
            border-left: 4px solid var(--primary);
            border-radius: 6px;
            padding: 1rem 1.25rem;
            margin: 1.5rem 0;
        }
        
        .learning-points h4 {
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .learning-points ul {
            list-style: none;
            padding-left: 0;
        }
        
        .learning-points li {
            padding-left: 1.5rem;
            position: relative;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
        }
        
        .learning-points li:before {
            content: "→";
            position: absolute;
            left: 0;
            color: var(--primary);
            font-weight: bold;
        }
        
        /* Demo Info */
        .demo-info {
            display: flex;
            justify-content: space-around;
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border-radius: 8px;
        }
        
        .demo-stat {
            text-align: center;
        }
        
        .demo-stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
        }
        
        .demo-stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary);
            font-family: monospace;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .concept-cards {
                grid-template-columns: 1fr;
            }
            
            .nav-buttons {
                flex-direction: column;
            }
            
            .control-grid {
                grid-template-columns: 1fr;
            }
            
            .run-button {
                grid-column: span 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-header">
            <div class="mathswell-nav">
                <a href="/">
                    <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
                    <span>MATHSWELL</span>
                </a>
            </div>
            <h1>Root-Finding Methods Explorer</h1>
            <p class="subtitle">Master numerical methods through interactive exploration</p>
        </div>
        
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('introduction')">Introduction</button>
            <button class="tab-button" onclick="switchTab('examples')">Explore Examples</button>
            <button class="tab-button" onclick="switchTab('custom')">Your Function</button>
        </div>
        
        <!-- Introduction Tab -->
        <div id="introduction-tab" class="tab-content active">
            <div class="section">
                <h2>What are Root-Finding Methods?</h2>
                <p style="color: var(--text-muted); line-height: 1.7; margin-bottom: 1rem;">
                    Root-finding methods are numerical algorithms that find values of x where a function f(x) equals zero. These "roots" or "zeros" are critical in engineering, physics, and mathematics for solving equations that can't be solved algebraically. Each method has different trade-offs between speed, reliability, and complexity.
                </p>
                
                <div class="concept-cards">
                    <div class="concept-card">
                        <h4>📊 Bracketing Methods</h4>
                        <p>Bisection and False Position methods trap the root between two points and systematically narrow the interval. They're reliable but can be slower.</p>
                    </div>
                    <div class="concept-card">
                        <h4>⚡ Open Methods</h4>
                        <p>Newton-Raphson and Secant methods use derivatives or slopes to rapidly converge. They're fast but require good initial guesses.</p>
                    </div>
                    <div class="concept-card">
                        <h4>🔄 Iterative Methods</h4>
                        <p>Fixed-Point iteration reformulates f(x)=0 as x=g(x) and iteratively refines the solution. Convergence depends on the choice of g(x).</p>
                    </div>
                </div>
                
                <h3>Interactive Demo: Watch Newton's Method Find a Root</h3>
                <div class="interactive-demo">
                    <div class="demo-controls">
                        <div class="demo-control">
                            <label>Function</label>
                            <select id="demo-function">
                                <option value="x^2 - 4">x² - 4 = 0</option>
                                <option value="x^3 - x - 2">x³ - x - 2 = 0</option>
                                <option value="cos(x) - x">cos(x) - x = 0</option>
                            </select>
                        </div>
                        <div class="demo-control">
                            <label>Initial Guess</label>
                            <input type="range" id="demo-x0" min="-3" max="3" step="0.1" value="3">
                            <span id="demo-x0-value" style="color: var(--primary); font-weight: bold;">3.0</span>
                        </div>
                        <div class="demo-control">
                            <label>Speed</label>
                            <select id="demo-speed">
                                <option value="1000">Slow</option>
                                <option value="500" selected>Normal</option>
                                <option value="200">Fast</option>
                            </select>
                        </div>
                        <div class="demo-control">
                            <label>&nbsp;</label>
                            <button id="demo-start" class="nav-button" style="margin: 0;">Start Animation</button>
                        </div>
                    </div>
                    <canvas id="demo-canvas"></canvas>
                    <div class="demo-info">
                        <div class="demo-stat">
                            <div class="demo-stat-label">Iteration</div>
                            <div class="demo-stat-value" id="demo-iteration">0</div>
                        </div>
                        <div class="demo-stat">
                            <div class="demo-stat-label">Current x</div>
                            <div class="demo-stat-value" id="demo-current-x">-</div>
                        </div>
                        <div class="demo-stat">
                            <div class="demo-stat-label">f(x)</div>
                            <div class="demo-stat-value" id="demo-fx">-</div>
                        </div>
                        <div class="demo-stat">
                            <div class="demo-stat-label">Error</div>
                            <div class="demo-stat-value" id="demo-error">-</div>
                        </div>
                    </div>
                </div>
                
                <h3>Two Key Perspectives</h3>
                <div class="insights-grid">
                    <div class="insight-card">
                        <h4>🎯 Convergence Rate</h4>
                        <p>Methods differ in how quickly they approach the root. Newton's method has quadratic convergence (error squares each iteration), while bisection has linear convergence (error halves each iteration).</p>
                    </div>
                    <div class="insight-card">
                        <h4>🛡️ Reliability vs Speed</h4>
                        <p>Bracketing methods always converge if the initial interval contains a root, but open methods can diverge with poor initial guesses. Choose based on your problem's requirements.</p>
                    </div>
                </div>
                
                <div class="nav-buttons">
                    <button class="nav-button" onclick="switchTab('examples')">
                        Explore Examples →
                    </button>
                    <button class="nav-button" onclick="switchTab('custom')">
                        Try Your Own →
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Examples Tab -->
        <div id="examples-tab" class="tab-content">
            <div class="section">
                <h2>Explore Example Functions</h2>
                <p style="color: var(--text-muted); margin-bottom: 1.5rem;">
                    Select a function below to see how different methods perform. Each example demonstrates unique convergence behaviors.
                </p>
                
                <div class="example-cards" id="example-cards">
                    <!-- Will be populated by JavaScript -->
                </div>
                
                <div class="function-preview">
                    <div class="function-card">
                        <div class="label">Root-finding problem:</div>
                        <div id="example-f-display" class="math-display"></div>
                    </div>
                    <div class="function-card">
                        <div class="label">Fixed-point iteration:</div>
                        <div id="example-g-display" class="math-display"></div>
                    </div>
                </div>
                
                <canvas id="examples-graph"></canvas>
                
                <button id="analyze-example-btn" class="run-button" style="width: 100%;">Analyze This Function</button>
                
                <div id="example-results" style="display: none;">
                    <h3>Results Summary</h3>
                    <div class="results-grid" id="example-results-grid">
                        <!-- Will be populated by JavaScript -->
                    </div>
                    
                    <div class="learning-points">
                        <h4>💡 Key Learning Points</h4>
                        <ul id="example-insights">
                            <!-- Will be populated based on results -->
                        </ul>
                    </div>
                    
                    <h3>Convergence Analysis</h3>
                    <div id="examples-plot-container">
                        <p>Click "Analyze This Function" to see the convergence plot.</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Custom Function Tab -->
        <div id="custom-tab" class="tab-content">
            <div class="section">
                <h2>Analyze Your Own Function</h2>
                <p style="color: var(--text-muted); margin-bottom: 0.5rem;">
                    Enter your function and get intelligent suggestions for fixed-point iteration forms.
                </p>
                <p style="color: var(--text-muted); font-size: 0.9rem; font-style: italic; margin-bottom: 1.5rem;">
                    *The AI assistant provides mathematical rearrangements but may occasionally make errors.
                </p>
                
                <div class="control-grid">
                    <div class="control-group">
                        <label>Enter equation (e.g., x^3 - 2*x - 5)</label>
                        <input type="text" id="custom-function-input" placeholder="x^3 - 2*x - 5">
                    </div>
                    <div class="control-group">
                        <label>Fixed-point form (AI will suggest if blank)</label>
                        <input type="text" id="custom-g-input" placeholder="Leave blank for AI suggestion">
                    </div>
                </div>
                
                <div style="display: flex; gap: 1rem; margin: 1rem 0;">
                    <button class="ai-button" onclick="askAI()" style="flex: 1;">🤖 AI Guide</button>
                    <button class="ai-button" onclick="resetCustom()" style="flex: 1; background: #6b7280;">🔄 Reset</button>
                </div>
                
                <div class="ai-assistant" id="ai-assistant" style="display: none;">
                    <div class="ai-hint">
                        <div class="ai-message" id="ai-message">
                            <!-- AI suggestions will appear here -->
                        </div>
                    </div>
                </div>
                
                <div class="function-preview">
                    <div class="function-card">
                        <div class="label">Your function:</div>
                        <div id="custom-f-display" class="math-display"></div>
                    </div>
                    <div class="function-card">
                        <div class="label">Fixed-point form:</div>
                        <div id="custom-g-display" class="math-display"></div>
                    </div>
                </div>
                
                <canvas id="function-graph"></canvas>
                
                <div class="control-grid">
                    <div class="control-group">
                        <label>Interval Start (a)</label>
                        <input type="number" id="a-input" step="any" value="-2">
                    </div>
                    <div class="control-group">
                        <label>Interval End (b)</label>
                        <input type="number" id="b-input" step="any" value="3">
                    </div>
                    <div class="control-group">
                        <label>Initial Guess (x₀)</label>
                        <input type="number" id="x0-input" step="any" value="0">
                    </div>
                    <div class="control-group">
                        <label>Second Guess (x₁)</label>
                        <input type="number" id="x1-input" step="any" value="1">
                    </div>
                    <button id="run-btn" class="run-button">Run Analysis</button>
                </div>
                
                <div id="custom-results" style="display: none;">
                    <h3>Results Summary</h3>
                    <div class="results-grid">
                        <div class="result-card">
                            <h4 class="bisection">Bisection</h4>
                            <div id="bisection-result" class="value">-</div>
                            <div id="bisection-status" class="status">Ready</div>
                        </div>
                        <div class="result-card">
                            <h4 class="false-pos">False Position</h4>
                            <div id="false-pos-result" class="value">-</div>
                            <div id="false-pos-status" class="status">Ready</div>
                        </div>
                        <div class="result-card">
                            <h4 class="secant">Secant</h4>
                            <div id="secant-result" class="value">-</div>
                            <div id="secant-status" class="status">Ready</div>
                        </div>
                        <div class="result-card">
                            <h4 class="newton">Newton-Raphson</h4>
                            <div id="newton-result" class="value">-</div>
                            <div id="newton-status" class="status">Ready</div>
                        </div>
                        <div class="result-card">
                            <h4 class="fixed-point">Fixed-Point</h4>
                            <div id="fixed-point-result" class="value">-</div>
                            <div id="fixed-point-status" class="status">Ready</div>
                        </div>
                    </div>
                    
                    <div id="convergence-summary" style="margin-top: 1.5rem; padding: 1rem; background: var(--interactive-bg); border-radius: 8px;">
                        <h4 style="color: var(--primary); margin-bottom: 0.5rem;">Analysis Summary</h4>
                        <p id="best-method" style="color: var(--text-muted); font-size: 0.95rem;"></p>
                    </div>
                    
                    <h3>Error Analysis</h3>
                    <div id="plot-container">
                        <p>Analysis results will appear here.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        const EXAMPLES = {
            simple_poly: {
                name: "Simple Polynomial",
                category: "Polynomial",
                f_string: "x^2 - 4",
                g_string: "sqrt(4)",
                a: 0, b: 3, x0: 1, x1: 3,
                insights: [
                    "Simple root at x = 2",
                    "All methods converge quickly",
                    "Newton achieves quadratic convergence"
                ]
            },
            cubic: {
                name: "Cubic Equation",
                category: "Polynomial",
                f_string: "x^3 - x - 2",
                g_string: "(x+2)^(1/3)",
                a: 1, b: 2, x0: 1.5, x1: 2,
                insights: [
                    "Single real root near x ≈ 1.52",
                    "Fixed-point may diverge without careful g(x) choice",
                    "Newton's method excels here"
                ]
            },
            transcendental: {
                name: "Cosine Fixed Point",
                category: "Transcendental",
                f_string: "cos(x) - x",
                g_string: "cos(x)",
                a: 0, b: 1, x0: 0.5, x1: 1,
                insights: [
                    "Root at x ≈ 0.739",
                    "Fixed-point iteration works well",
                    "Bisection provides guaranteed convergence"
                ]
            },
            exponential: {
                name: "Exponential Equation",
                category: "Transcendental", 
                f_string: "x - exp(-x)",
                g_string: "exp(-x)",
                a: 0, b: 1, x0: 0.5, x1: 0.6,
                insights: [
                    "Root at x ≈ 0.567",
                    "All methods work reasonably well",
                    "Good example for comparing convergence rates"
                ]
            },
            steep: {
                name: "Steep Function",
                category: "Challenging",
                f_string: "x^10 - 1",
                g_string: "1^(1/10)",
                a: 0, b: 2, x0: 0.5, x1: 1.5,
                insights: [
                    "Very steep near the root x = 1",
                    "Bisection slow but reliable",
                    "Newton may overshoot if starting far from root"
                ]
            },
            multiple_roots: {
                name: "Multiple Roots",
                category: "Challenging",
                f_string: "(x-1)^2 * (x+2)",
                g_string: "x - ((x-1)^2 * (x+2))/3",
                a: -3, b: 2, x0: 0, x1: 0.5,
                insights: [
                    "Double root at x = 1, single at x = -2",
                    "Newton converges slowly near double root",
                    "Bisection finds single roots reliably"
                ]
            }
        };
        
        let currentExample = 'simple_poly';
        let analysisResults = null;
        let exampleResults = null;
        let errorChart = null;
        let exampleChart = null;
        let demoAnimation = null;
        
        // DOM elements cache
        const DOM = {};
        
        // Convert math input to LaTeX
        function mathInputToLatex(input) {
            if (!input) return '';
            
            let latex = input
                .replace(/\bsin\(/g, '\\sin(')
                .replace(/\bcos\(/g, '\\cos(')
                .replace(/\btan\(/g, '\\tan(')
                .replace(/\bln\(/g, '\\ln(')
                .replace(/\blog\(/g, '\\log(')
                .replace(/\bexp\(/g, 'e^{')
                .replace(/\bsqrt\(/g, '\\sqrt{')
                .replace(/\babs\(/g, '|')
                .replace(/\^(-?\d+)/g, '^{$1}')
                .replace(/\^(\([^)]+\))/g, function(match, p1) {
                    return '^{' + p1.slice(1, -1) + '}';
                })
                .replace(/e\^\{([^}]+)\}/g, 'e^{$1}')
                .replace(/e\^{([^}]*)(\))/g, 'e^{$1}')
                .replace(/\\sqrt{([^}]*)(\))/g, '\\sqrt{$1}')
                .replace(/\|([^|]*)\)/g, '|$1|')
                .replace(/\*/g, ' \\cdot ')
                .replace(/([+-])/g, ' $1 ');
            
            return latex;
        }
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            // Cache DOM elements
            const elements = [
                'custom-function-input', 'custom-g-input', 'a-input', 'b-input',
                'x0-input', 'x1-input', 'run-btn', 'plot-container',
                'demo-function', 'demo-x0', 'demo-x0-value', 'demo-speed', 'demo-start',
                'demo-iteration', 'demo-current-x', 'demo-fx', 'demo-error',
                'custom-f-display', 'custom-g-display', 'ai-assistant', 'ai-message',
                'example-f-display', 'example-g-display', 'analyze-example-btn',
                'example-results', 'example-results-grid', 'example-insights',
                'custom-results', 'convergence-summary', 'best-method'
            ];
            
            elements.forEach(id => {
                DOM[id.replace(/-./g, m => m[1].toUpperCase())] = document.getElementById(id);
            });
            
            setupEventListeners();
            initializeDemo();
            createExampleCards();
            loadExample(currentExample);
        });
        
        function setupEventListeners() {
            // Custom function inputs
            DOM.customFunctionInput.addEventListener('input', () => {
                // Clear g(x) when f(x) changes
                DOM.customGInput.value = '';
                updateCustomDisplays();
            });
            
            DOM.customGInput.addEventListener('input', () => {
                updateCustomDisplays();
                validateFixedPoint();
            });
            
            // When user focuses on g(x) input, provide AI hint
            DOM.customGInput.addEventListener('focus', async () => {
                const fString = DOM.customFunctionInput.value;
                if (fString && !DOM.customGInput.value) {
                    DOM.aiAssistant.style.display = 'block';
                    DOM.aiMessage.innerHTML = '💡 Getting suggestion for fixed-point form...';
                    const suggestion = await getIntelligentSuggestion(fString);
                    DOM.aiMessage.innerHTML = `💡 <strong>Suggestion:</strong> Try g(x) = ${suggestion}. This rearranges your equation for iteration.`;
                }
            });
            
            DOM.aInput.addEventListener('input', updateCustomDisplays);
            DOM.bInput.addEventListener('input', updateCustomDisplays);
            DOM.x0Input.addEventListener('input', updateCustomDisplays);
            DOM.x1Input.addEventListener('input', updateCustomDisplays);
            
            // Run analysis button
            DOM.runBtn.addEventListener('click', runCustomAnalysis);
            
            // Analyze example button
            DOM.analyzeExampleBtn.addEventListener('click', analyzeExample);
            
            // Demo controls
            DOM.demoX0.addEventListener('input', (e) => {
                DOM.demoX0Value.textContent = parseFloat(e.target.value).toFixed(1);
            });
            DOM.demoStart.addEventListener('click', startDemoAnimation);
        }
        
        async function validateFixedPoint() {
            const fString = DOM.customFunctionInput.value;
            const gString = DOM.customGInput.value;
            
            if (fString && gString) {
                DOM.aiAssistant.style.display = 'block';
                
                // Check if g(x) is reasonable for the given f(x)
                try {
                    const g_compiled = math.compile(gString.replace(/cosx/gi, 'cos(x)').replace(/sinx/gi, 'sin(x)'));
                    const g_test = g_compiled.evaluate({x: 1});
                    
                    if (isFinite(g_test)) {
                        DOM.aiMessage.innerHTML = `💡 <strong>Fixed-point set!</strong> Remember: convergence requires |g'(x)| < 1 near the root.`;
                    }
                } catch (e) {
                    DOM.aiMessage.innerHTML = `💡 <strong>Check syntax:</strong> Use * for multiplication, parentheses for grouping.`;
                }
            }
        }
        
        // ENHANCED AI SUGGESTION SYSTEM
        async function getIntelligentSuggestion(fString) {
            // First try intelligent pattern recognition
            const localSuggestion = getSmartRearrangement(fString);
            if (localSuggestion !== null) {
                return localSuggestion;
            }
            
            // Then try AI with improved prompting
            return await getAISuggestion(fString);
        }
        
        function getSmartRearrangement(fString) {
            // Clean and normalize the function
            const cleaned = fString.toLowerCase().trim();
            
            // Pattern 1: Direct isolation (x - h(x) = 0 → x = h(x))
            if (cleaned.match(/^x\s*[-+]\s*.+/) && !cleaned.includes('*x') && !cleaned.includes('x^')) {
                // Extract h(x) from x - h(x) = 0
                if (cleaned.startsWith('x -')) {
                    const hx = cleaned.substring(3).trim();
                    return hx;
                } else if (cleaned.startsWith('x +')) {
                    const hx = cleaned.substring(3).trim();
                    return `-${hx}`;
                }
            }
            
            // Pattern 2: Cosine equations (cos(x) - x = 0 → x = cos(x))
            if (cleaned.includes('cos(x)') && cleaned.includes('- x')) {
                return 'cos(x)';
            }
            if (cleaned.includes('x - cos(x)')) {
                return 'cos(x)';
            }
            
            // Pattern 3: Sine equations
            if (cleaned.includes('sin(x)') && cleaned.includes('- x')) {
                return 'sin(x)';
            }
            
            // Pattern 4: Exponential equations (x - exp(-x) = 0 → x = exp(-x))
            if (cleaned.match(/x\s*-\s*exp?\(-x\)/)) {
                return 'exp(-x)';
            }
            if (cleaned.match(/x\s*-\s*e\^-x/)) {
                return 'e^(-x)';
            }
            
            // Pattern 5: Square root isolation (x^2 - c = 0 → x = sqrt(c))
            const squarePattern = cleaned.match(/x\^2\s*[-+]\s*(\d+(?:\.\d+)?)/);
            if (squarePattern) {
                const constant = parseFloat(squarePattern[1]);
                if (cleaned.includes('-')) {
                    return `sqrt(${constant})`;
                } else {
                    return `sqrt(${-constant})`;
                }
            }
            
            // Pattern 6: Cubic isolation (x^3 - ax - b = 0 → x = (ax + b)^(1/3))
            const cubicPattern = cleaned.match(/x\^3\s*[-+]\s*(\d*(?:\.\d+)?)\*?x?\s*[-+]\s*(\d+(?:\.\d+)?)/);
            if (cubicPattern) {
                const aCoeff = cubicPattern[1] || '1';
                const bConst = cubicPattern[2];
                return `(${aCoeff}*x + ${bConst})^(1/3)`;
            }
            
            // Pattern 7: Linear in different forms (ax - b = 0 → x = b/a)
            const linearPattern = cleaned.match(/(\d+(?:\.\d+)?)\*?x\s*[-+]\s*(\d+(?:\.\d+)?)/);
            if (linearPattern && !cleaned.includes('^')) {
                const a = parseFloat(linearPattern[1]);
                const b = parseFloat(linearPattern[2]);
                if (cleaned.includes('-')) {
                    return (b / a).toString();
                } else {
                    return (-b / a).toString();
                }
            }
            
            // Pattern 8: Rational functions
            if (cleaned.includes('/')) {
                // For equations like x - a/x = 0, suggest x = a/x
                const rationalPattern = cleaned.match(/x\s*[-+]\s*(\d+(?:\.\d+)?)\s*\/\s*x/);
                if (rationalPattern) {
                    const a = rationalPattern[1];
                    return cleaned.includes('-') ? `${a}/x` : `-${a}/x`;
                }
            }
            
            return null; // No pattern recognized
        }
        
        async function getAISuggestion(fString) {
            // Enhanced prompt for much better AI suggestions
            const prompt = `
Given the equation: ${fString} = 0

Find a mathematically meaningful rearrangement for fixed-point iteration g(x).

RULES FOR GOOD REARRANGEMENTS:
1. For x - h(x) = 0, use g(x) = h(x)
2. For x^2 - c = 0, use g(x) = sqrt(c) 
3. For x^3 - ax - b = 0, use g(x) = (ax + b)^(1/3)
4. For transcendental equations, isolate x creatively

EXAMPLES:
- cos(x) - x = 0 → g(x) = cos(x)
- x^2 - 4 = 0 → g(x) = sqrt(4) or g(x) = 2
- x - exp(-x) = 0 → g(x) = exp(-x)
- x^3 - 2x - 5 = 0 → g(x) = (2x + 5)^(1/3)

Your turn. Provide ONLY the g(x) expression, no explanation.
For: ${fString} = 0
Answer: g(x) = `;

            try {
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 100,
                        messages: [{ role: "user", content: prompt }]
                    })
                });
                
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const result = await response.json();
                const text = result.content?.[0]?.text;
                
                if (text && text.trim()) {
                    // Clean up the response
                    const cleaned = text.trim()
                        .replace(/g\(x\)\s*=\s*/i, '')
                        .replace(/```[^`]*```/g, '')
                        .split('\n')[0]
                        .trim();
                    
                    // Validate the suggestion makes sense
                    if (cleaned && cleaned.length > 0 && cleaned.length < 50) {
                        return cleaned;
                    }
                }
            } catch (e) {
                console.log('AI suggestion failed:', e);
            }
            
            // Enhanced fallback system
            return getEnhancedFallback(fString);
        }
        
        function getEnhancedFallback(fString) {
            const cleaned = fString.toLowerCase().trim();
            
            // Smart fallbacks based on function structure
            if (cleaned.includes('cos')) return 'cos(x)';
            if (cleaned.includes('sin')) return 'sin(x)';
            if (cleaned.includes('exp') || cleaned.includes('e^')) return 'exp(-x)';
            if (cleaned.includes('ln') || cleaned.includes('log')) return 'exp(x-1)';
            
            // Polynomial fallbacks
            if (cleaned.includes('x^3')) {
                return 'x - (x^3 - 2*x - 5)/(3*x^2 - 2)'; // Newton-like rearrangement
            }
            if (cleaned.includes('x^2')) {
                const match = cleaned.match(/(\d+)/);
                const constant = match ? match[1] : '4';
                return `sqrt(${constant})`;
            }
            
            // Default: simple rearrangement
            return `x - (${fString})/2`;
        }
        
        function createExampleCards() {
            const container = document.getElementById('example-cards');
            
            Object.entries(EXAMPLES).forEach(([key, example]) => {
                const card = document.createElement('div');
                card.className = 'example-card';
                if (key === currentExample) card.classList.add('active');
                
                card.innerHTML = `
                    <div class="category">${example.category}</div>
                    <div class="formula">${example.name}</div>
                `;
                
                card.onclick = () => {
                    document.querySelectorAll('.example-card').forEach(c => c.classList.remove('active'));
                    card.classList.add('active');
                    currentExample = key;
                    loadExample(key);
                };
                
                container.appendChild(card);
            });
        }
        
        function loadExample(key) {
            const example = EXAMPLES[key];
            
            // Update displays
            const fLatex = mathInputToLatex(example.f_string);
            const gLatex = mathInputToLatex(example.g_string);
            
            DOM.exampleFDisplay.innerHTML = '';
            katex.render(fLatex + ' = 0', DOM.exampleFDisplay, {
                throwOnError: false,
                displayMode: true
            });
            
            DOM.exampleGDisplay.innerHTML = '';
            katex.render('x = ' + gLatex, DOM.exampleGDisplay, {
                throwOnError: false,
                displayMode: true
            });
            
            // Draw graph
            drawExampleGraph(example);
            
            // Hide results initially
            DOM.exampleResults.style.display = 'none';
        }
        
        function drawExampleGraph(example) {
            const canvas = document.getElementById('examples-graph');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = 250;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            let func;
            try {
                func = math.compile(example.f_string);
            } catch (e) {
                return;
            }
            
            const xMin = example.a - 1;
            const xMax = example.b + 1;
            const padding = 30;
            
            // Calculate y bounds
            let yMin = Infinity, yMax = -Infinity;
            for (let px = 0; px < canvas.width; px++) {
                const x = xMin + (px / canvas.width) * (xMax - xMin);
                try {
                    const y = func.evaluate({x: x});
                    if (isFinite(y)) {
                        yMin = Math.min(yMin, y);
                        yMax = Math.max(yMax, y);
                    }
                } catch (e) {}
            }
            
            const yPadding = (yMax - yMin) * 0.1 || 1;
            yMin -= yPadding;
            yMax += yPadding;
            
            function toCanvasX(x) {
                return padding + (x - xMin) / (xMax - xMin) * (canvas.width - 2 * padding);
            }
            
            function toCanvasY(y) {
                return canvas.height - padding - (y - yMin) / (yMax - yMin) * (canvas.height - 2 * padding);
            }
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = xMin + i * (xMax - xMin) / 10;
                ctx.beginPath();
                ctx.moveTo(toCanvasX(x), padding);
                ctx.lineTo(toCanvasX(x), canvas.height - padding);
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(0), padding);
            ctx.lineTo(toCanvasX(0), canvas.height - padding);
            ctx.moveTo(padding, toCanvasY(0));
            ctx.lineTo(canvas.width - padding, toCanvasY(0));
            ctx.stroke();
            
            // Draw interval
            ctx.fillStyle = 'rgba(15, 118, 110, 0.1)';
            ctx.fillRect(toCanvasX(example.a), padding, toCanvasX(example.b) - toCanvasX(example.a), canvas.height - 2 * padding);
            
            // Draw function
            ctx.strokeStyle = '#0f766e';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            let firstPoint = true;
            
            for (let px = 0; px < canvas.width; px++) {
                const x = xMin + (px / canvas.width) * (xMax - xMin);
                try {
                    const y = func.evaluate({x: x});
                    if (isFinite(y)) {
                        if (firstPoint) {
                            ctx.moveTo(toCanvasX(x), toCanvasY(y));
                            firstPoint = false;
                        } else {
                            ctx.lineTo(toCanvasX(x), toCanvasY(y));
                        }
                    }
                } catch (e) {}
            }
            ctx.stroke();
            
            // Draw initial points
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(toCanvasX(example.x0), toCanvasY(0), 5, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(toCanvasX(example.x1), toCanvasY(0), 5, 0, 2 * Math.PI);
            ctx.fill();
        }
        
        function analyzeExample() {
            const example = EXAMPLES[currentExample];
            
            // Compile functions
            let f_compiled, f_prime_compiled, g_compiled;
            try {
                f_compiled = math.compile(example.f_string);
                f_prime_compiled = math.derivative(example.f_string, 'x').compile();
                g_compiled = math.compile(example.g_string);
            } catch (e) {
                alert('Error compiling functions');
                return;
            }
            
            // Find benchmark root
            const benchmarkRoot = findBenchmarkRoot(f_compiled, f_prime_compiled, example.x0);
            
            if (isNaN(benchmarkRoot)) {
                alert('Could not find benchmark root');
                return;
            }
            
            // Run all methods
            exampleResults = {
                'bisection': runBisection(f_compiled, example.a, example.b, benchmarkRoot, 30),
                'false-pos': runFalsePosition(f_compiled, example.a, example.b, benchmarkRoot, 30),
                'secant': runSecant(f_compiled, example.x0, example.x1, benchmarkRoot, 30),
                'newton': runNewton(f_compiled, f_prime_compiled, example.x0, benchmarkRoot, 30),
                'fixed-point': runFixedPoint(g_compiled, example.x0, benchmarkRoot, 30)
            };
            
            // Display results
            displayExampleResults(exampleResults, example);
            
            // Draw convergence plot
            drawExampleConvergencePlot(exampleResults);
            
            // Show results section
            DOM.exampleResults.style.display = 'block';
        }
        
        function displayExampleResults(results, example) {
            const grid = DOM.exampleResultsGrid;
            grid.innerHTML = '';
            
            let bestMethod = null;
            let bestIterations = Infinity;
            
            Object.entries(results).forEach(([method, result]) => {
                const card = document.createElement('div');
                card.className = 'result-card';
                
                const methodName = method.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
                const converged = result.status && result.status.startsWith('Converged');
                
                card.innerHTML = `
                    <h4 class="${method}">${methodName}</h4>
                    <div class="value">${converged ? result.root.toFixed(7) : '-'}</div>
                    <div class="status ${converged ? 'converged' : 'failed'}">${result.status}</div>
                `;
                
                grid.appendChild(card);
                
                if (converged) {
                    const iterations = parseInt(result.status.match(/\d+/)?.[0] || Infinity);
                    if (iterations < bestIterations) {
                        bestIterations = iterations;
                        bestMethod = methodName;
                    }
                }
            });
            
            // Update insights
            const insights = DOM.exampleInsights;
            insights.innerHTML = '';
            
            example.insights.forEach(insight => {
                const li = document.createElement('li');
                li.textContent = insight;
                insights.appendChild(li);
            });
            
            if (bestMethod) {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${bestMethod} performed best with ${bestIterations} iterations</strong>`;
                insights.appendChild(li);
            }
        }
        
        function drawExampleConvergencePlot(results) {
            const container = document.getElementById('examples-plot-container');
            container.innerHTML = '<canvas id="example-error-chart"></canvas>';
            const canvas = document.getElementById('example-error-chart');
            
            if (exampleChart) {
                exampleChart.destroy();
            }
            
            const datasets = Object.keys(results).map(key => ({
                label: key.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()),
                data: results[key].errors,
                borderColor: getMethodColor(key),
                backgroundColor: getMethodColor(key) + '20',
                tension: 0.1,
                fill: false,
                pointRadius: 3,
                pointHoverRadius: 5
            })).filter(ds => ds.data);
            
            exampleChart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: Array.from({length: 31}, (_, i) => i),
                    datasets: datasets
                },
                options: getChartOptions()
            });
        }
        
        function updateCustomDisplays() {
            const fInput = DOM.customFunctionInput.value;
            const gInput = DOM.customGInput.value;
            
            // Show AI assistant if function entered
            if (fInput) {
                DOM.aiAssistant.style.display = 'block';
            }
            
            // Display functions
            if (fInput) {
                const fLatex = mathInputToLatex(fInput);
                DOM.customFDisplay.innerHTML = '';
                katex.render(fLatex + ' = 0', DOM.customFDisplay, {
                    throwOnError: false,
                    displayMode: true
                });
            }
            
            if (gInput) {
                const gLatex = mathInputToLatex(gInput);
                DOM.customGDisplay.innerHTML = '';
                katex.render('x = ' + gLatex, DOM.customGDisplay, {
                    throwOnError: false,
                    displayMode: true
                });
            }
            
            // Draw graph
            drawCustomGraph();
        }
        
        function drawCustomGraph() {
            const canvas = document.getElementById('function-graph');
            const ctx = canvas.getContext('2d');
            
            canvas.width = canvas.offsetWidth;
            canvas.height = 250;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Clean up the function string for proper parsing
            let fString = DOM.customFunctionInput.value;
            if (!fString) {
                ctx.fillStyle = '#9e9e9e';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Enter a function to see the graph', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Auto-fix common syntax issues
            fString = fString
                .replace(/cosx/gi, 'cos(x)')
                .replace(/sinx/gi, 'sin(x)')
                .replace(/tanx/gi, 'tan(x)')
                .replace(/lnx/gi, 'ln(x)')
                .replace(/logx/gi, 'log(x)')
                .replace(/expx/gi, 'exp(x)');
            
            let func;
            try {
                func = math.compile(fString);
                // Test evaluation to catch runtime errors
                func.evaluate({x: 0});
            } catch (e) {
                ctx.fillStyle = '#dc2626';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Error: Check function syntax', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const a = parseFloat(DOM.aInput.value) || -2;
            const b = parseFloat(DOM.bInput.value) || 2;
            const x0 = parseFloat(DOM.x0Input.value) || 0;
            const x1 = parseFloat(DOM.x1Input.value) || 1;
            
            const xMin = Math.min(a - 1, -3);
            const xMax = Math.max(b + 1, 3);
            const padding = 30;
            
            // Calculate y bounds by sampling
            let yMin = Infinity, yMax = -Infinity;
            let hasValidPoints = false;
            
            for (let px = 0; px < canvas.width; px++) {
                const x = xMin + (px / canvas.width) * (xMax - xMin);
                try {
                    const y = func.evaluate({x: x});
                    if (isFinite(y) && Math.abs(y) < 100) {
                        yMin = Math.min(yMin, y);
                        yMax = Math.max(yMax, y);
                        hasValidPoints = true;
                    }
                } catch (e) {}
            }
            
            if (!hasValidPoints) {
                ctx.fillStyle = '#dc2626';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Unable to plot function in this range', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            const yPadding = (yMax - yMin) * 0.1 || 1;
            yMin -= yPadding;
            yMax += yPadding;
            
            function toCanvasX(x) {
                return padding + (x - xMin) / (xMax - xMin) * (canvas.width - 2 * padding);
            }
            
            function toCanvasY(y) {
                return canvas.height - padding - (y - yMin) / (yMax - yMin) * (canvas.height - 2 * padding);
            }
            
            // Draw grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const x = xMin + i * (xMax - xMin) / 10;
                ctx.beginPath();
                ctx.moveTo(toCanvasX(x), padding);
                ctx.lineTo(toCanvasX(x), canvas.height - padding);
                ctx.stroke();
                
                const y = yMin + i * (yMax - yMin) / 10;
                ctx.beginPath();
                ctx.moveTo(padding, toCanvasY(y));
                ctx.lineTo(canvas.width - padding, toCanvasY(y));
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(0), padding);
            ctx.lineTo(toCanvasX(0), canvas.height - padding);
            ctx.moveTo(padding, toCanvasY(0));
            ctx.lineTo(canvas.width - padding, toCanvasY(0));
            ctx.stroke();
            
            // Draw interval [a, b] - shaded region
            ctx.fillStyle = 'rgba(15, 118, 110, 0.1)';
            ctx.fillRect(toCanvasX(a), padding, toCanvasX(b) - toCanvasX(a), canvas.height - 2 * padding);
            
            // Draw interval markers
            ctx.strokeStyle = 'rgba(15, 118, 110, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(toCanvasX(a), padding);
            ctx.lineTo(toCanvasX(a), canvas.height - padding);
            ctx.moveTo(toCanvasX(b), padding);
            ctx.lineTo(toCanvasX(b), canvas.height - padding);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw function
            ctx.strokeStyle = '#0f766e';
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            let firstPoint = true;
            
            for (let px = 0; px < canvas.width; px++) {
                const x = xMin + (px / canvas.width) * (xMax - xMin);
                try {
                    const y = func.evaluate({x: x});
                    if (isFinite(y) && Math.abs(y) < 100) {
                        if (firstPoint) {
                            ctx.moveTo(toCanvasX(x), toCanvasY(y));
                            firstPoint = false;
                        } else {
                            ctx.lineTo(toCanvasX(x), toCanvasY(y));
                        }
                    } else {
                        firstPoint = true;
                    }
                } catch (e) {
                    firstPoint = true;
                }
            }
            ctx.stroke();
            
            // Draw initial points
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(toCanvasX(x0), toCanvasY(0), 5, 0, 2 * Math.PI);
            ctx.fill();
            
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.arc(toCanvasX(x1), toCanvasY(0), 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Add labels for initial guesses
            ctx.fillStyle = '#4b5563';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x₀', toCanvasX(x0), toCanvasY(0) + 20);
            ctx.fillText('x₁', toCanvasX(x1), toCanvasY(0) + 20);
            
            // Add legend/guide
            ctx.font = '11px sans-serif';
            ctx.fillStyle = '#4b5563';
            ctx.textAlign = 'left';
            
            // Legend box
            const legendY = 10;
            ctx.fillText('Green area: Search interval [a,b]', padding, legendY);
            ctx.fillStyle = '#f59e0b';
            ctx.fillRect(padding, legendY + 5, 10, 10);
            ctx.fillStyle = '#4b5563';
            ctx.fillText('= x₀', padding + 15, legendY + 14);
            
            ctx.fillStyle = '#dc2626';
            ctx.fillRect(padding + 50, legendY + 5, 10, 10);
            ctx.fillStyle = '#4b5563';
            ctx.fillText('= x₁', padding + 65, legendY + 14);
        }
        
        async function runCustomAnalysis() {
            const fString = DOM.customFunctionInput.value;
            let gString = DOM.customGInput.value;
            
            if (!fString) {
                alert('Please enter a function');
                return;
            }
            
            // Clean up the function string for proper parsing
            const cleanedF = fString
                .replace(/cosx/gi, 'cos(x)')
                .replace(/sinx/gi, 'sin(x)')
                .replace(/tanx/gi, 'tan(x)')
                .replace(/lnx/gi, 'ln(x)')
                .replace(/logx/gi, 'log(x)')
                .replace(/expx/gi, 'exp(x)');
            
            // If no g(x) provided, get intelligent suggestion
            if (!gString) {
                DOM.aiAssistant.style.display = 'block';
                DOM.aiMessage.innerHTML = '💡 Finding a good fixed-point form...';
                gString = await getIntelligentSuggestion(cleanedF);
                DOM.customGInput.value = gString;
                updateCustomDisplays();
            }
            
            // Compile functions
            let f_compiled, f_prime_compiled, g_compiled;
            try {
                f_compiled = math.compile(cleanedF);
                f_prime_compiled = math.derivative(cleanedF, 'x').compile();
                g_compiled = math.compile(gString);
            } catch (e) {
                DOM.aiAssistant.style.display = 'block';
                DOM.aiMessage.innerHTML = '💡 <strong>Error:</strong> Check your function syntax. Try using * for multiplication and parentheses for grouping.';
                return;
            }
            
            const a = parseFloat(DOM.aInput.value);
            const b = parseFloat(DOM.bInput.value);
            const x0 = parseFloat(DOM.x0Input.value);
            const x1 = parseFloat(DOM.x1Input.value);
            
            // Find benchmark root
            const benchmarkRoot = findBenchmarkRoot(f_compiled, f_prime_compiled, x0);
            
            if (isNaN(benchmarkRoot)) {
                DOM.aiAssistant.style.display = 'block';
                DOM.aiMessage.innerHTML = '💡 <strong>Having trouble finding a root.</strong> Try adjusting your initial guesses or check if the function has roots in this interval.';
                return;
            }
            
            // Run all methods
            analysisResults = {
                'bisection': runBisection(f_compiled, a, b, benchmarkRoot, 30),
                'false-pos': runFalsePosition(f_compiled, a, b, benchmarkRoot, 30),
                'secant': runSecant(f_compiled, x0, x1, benchmarkRoot, 30),
                'newton': runNewton(f_compiled, f_prime_compiled, x0, benchmarkRoot, 30),
                'fixed-point': runFixedPoint(g_compiled, x0, benchmarkRoot, 30)
            };
            
            // Display results
            updateSummaryCards(analysisResults);
            drawErrorPlot();
            
            // Show results section
            DOM.customResults.style.display = 'block';
            
            // Show success message
            DOM.aiAssistant.style.display = 'block';
            DOM.aiMessage.innerHTML = '💡 <strong>Analysis complete!</strong> Found root at x ≈ ' + benchmarkRoot.toFixed(6) + '. See results below.';
        }
        
        async function askAI() {
            const fString = DOM.customFunctionInput.value;
            if (!fString) {
                DOM.aiMessage.textContent = 'Enter a function first!';
                return;
            }
            
            DOM.aiMessage.textContent = 'Analyzing your function...';
            
            const analysis = await getAIAnalysis(fString);
            DOM.aiMessage.innerHTML = analysis;
        }
        
        async function getAIAnalysis(fString) {
            const prompt = `
            Analyze this function for root-finding: ${fString} = 0
            
            Provide 2-3 brief educational tips about:
            1. Which method works best and why
            2. Good initial guess strategy  
            3. Any potential challenges (multiple roots, discontinuities, etc.)
            
            Keep it concise and student-friendly!
            `;
            
            try {
                const response = await fetch("https://api.anthropic.com/v1/messages", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify({
                        model: "claude-sonnet-4-20250514",
                        max_tokens: 200,
                        messages: [{ role: "user", content: prompt }]
                    })
                });
                
                if (!response.ok) throw new Error(`API error: ${response.status}`);
                
                const result = await response.json();
                const analysis = result.content?.[0]?.text;
                
                return analysis?.replace(/\*\*/g, '').replace(/\*/g, '•') 
                    || "💡 Quick tips: Newton's method usually works best for smooth functions. Try starting near where the function crosses zero. If one method fails, bisection always works if you bracket the root!";
            } catch (e) {
                console.log('AI analysis failed:', e);
                return "💡 Quick tips: Newton's method usually works best for smooth functions. Try starting near where the function crosses zero. If one method fails, bisection always works if you bracket the root!";
            }
        }
        
        // Root-finding methods
        function findBenchmarkRoot(f_compiled, f_prime_compiled, x0) {
            let x = x0;
            for (let i = 0; i < 100; i++) {
                try {
                    const fx = f_compiled.evaluate({x: x});
                    const fpx = f_prime_compiled.evaluate({x: x});
                    if (Math.abs(fpx) < 1e-14) return NaN;
                    const xNew = x - fx / fpx;
                    if (Math.abs(xNew - x) < 1e-15) return xNew;
                    x = xNew;
                } catch {
                    return NaN;
                }
            }
            return x;
        }
        
        const TOLERANCE = 1e-12;
        
        function runBisection(f_compiled, a, b, root, maxIter) {
            const errors = [];
            try {
                if (f_compiled.evaluate({x: a}) * f_compiled.evaluate({x: b}) >= 0) {
                    return { status: "Failed: Bad interval" };
                }
            } catch {
                return { status: "Failed: Eval error" };
            }
            
            for (let i = 0; i < maxIter; i++) {
                const m = (a + b) / 2;
                errors.push(Math.max(1e-16, Math.abs(m - root)));
                
                if (Math.abs(b - a) / 2 < TOLERANCE) {
                    return { status: `Converged in ${i} iter.`, root: m, errors };
                }
                
                if (f_compiled.evaluate({x: a}) * f_compiled.evaluate({x: m}) < 0) {
                    b = m;
                } else {
                    a = m;
                }
            }
            
            return { status: "Max iterations", root: (a + b) / 2, errors };
        }
        
        function runFalsePosition(f_compiled, a, b, root, maxIter) {
            const errors = [];
            try {
                if (f_compiled.evaluate({x: a}) * f_compiled.evaluate({x: b}) >= 0) {
                    return { status: "Failed: Bad interval" };
                }
            } catch {
                return { status: "Failed: Eval error" };
            }
            
            let c = b;
            for (let i = 0; i < maxIter; i++) {
                const fa = f_compiled.evaluate({x: a});
                const fb = f_compiled.evaluate({x: b});
                const prev_c = c;
                
                if (Math.abs(fb - fa) < 1e-14) {
                    return { status: "Failed: Flat slope", root: c, errors };
                }
                
                c = (a * fb - b * fa) / (fb - fa);
                
                if (isNaN(c) || !isFinite(c)) {
                    return { status: "Failed: Diverged", root: prev_c, errors };
                }
                
                errors.push(Math.max(1e-16, Math.abs(c - root)));
                
                if (Math.abs(f_compiled.evaluate({x: c})) < TOLERANCE) {
                    return { status: `Converged in ${i + 1} iter.`, root: c, errors };
                }
                
                if (f_compiled.evaluate({x: a}) * f_compiled.evaluate({x: c}) < 0) {
                    b = c;
                } else {
                    a = c;
                }
            }
            
            return { status: "Max iterations", root: c, errors };
        }
        
        function runSecant(f_compiled, x0, x1, root, maxIter) {
            const errors = [Math.max(1e-16, Math.abs(x0 - root)), Math.max(1e-16, Math.abs(x1 - root))];
            
            for (let i = 0; i < maxIter; i++) {
                const fx0 = f_compiled.evaluate({x: x0});
                const fx1 = f_compiled.evaluate({x: x1});
                
                if (Math.abs(fx1 - fx0) < 1e-14) {
                    return { status: "Failed: Flat slope", root: x1, errors };
                }
                
                const x2 = x1 - fx1 * (x1 - x0) / (fx1 - fx0);
                
                if (isNaN(x2) || !isFinite(x2)) {
                    return { status: "Failed: Diverged", root: x1, errors };
                }
                
                errors.push(Math.max(1e-16, Math.abs(x2 - root)));
                
                if (Math.abs(x2 - x1) < TOLERANCE) {
                    return { status: `Converged in ${i + 1} iter.`, root: x2, errors };
                }
                
                x0 = x1;
                x1 = x2;
            }
            
            return { status: "Max iterations", root: x1, errors };
        }
        
        function runNewton(f_compiled, f_prime_compiled, x0, root, maxIter) {
            const errors = [Math.max(1e-16, Math.abs(x0 - root))];
            
            for (let i = 0; i < maxIter; i++) {
                const fx0 = f_compiled.evaluate({x: x0});
                const fpx0 = f_prime_compiled.evaluate({x: x0});
                
                if (Math.abs(fpx0) < 1e-14) {
                    return { status: "Failed: Zero derivative", root: x0, errors };
                }
                
                const x1 = x0 - fx0 / fpx0;
                
                if (isNaN(x1) || !isFinite(x1)) {
                    return { status: "Failed: Diverged", root: x0, errors };
                }
                
                errors.push(Math.max(1e-16, Math.abs(x1 - root)));
                
                if (Math.abs(x1 - x0) < TOLERANCE) {
                    return { status: `Converged in ${i + 1} iter.`, root: x1, errors };
                }
                
                x0 = x1;
            }
            
            return { status: "Max iterations", root: x0, errors };
        }
        
        function runFixedPoint(g_compiled, x0, root, maxIter) {
            const errors = [Math.max(1e-16, Math.abs(x0 - root))];
            
            for (let i = 0; i < maxIter; i++) {
                let x1;
                try {
                    x1 = g_compiled.evaluate({x: x0});
                } catch {
                    return { status: "Failed: Eval error", errors };
                }
                
                if (isNaN(x1) || !isFinite(x1)) {
                    return { status: "Failed: Diverged", root: x0, errors };
                }
                
                errors.push(Math.max(1e-16, Math.abs(x1 - root)));
                
                if (Math.abs(x1 - x0) < TOLERANCE) {
                    return { status: `Converged in ${i + 1} iter.`, root: x1, errors };
                }
                
                x0 = x1;
            }
            
            return { status: "Max iterations", root: x0, errors };
        }
        
        function updateSummaryCards(results) {
            let bestMethod = null;
            let bestIterations = Infinity;
            
            Object.keys(results).forEach(key => {
                const res = results[key];
                const resultEl = document.getElementById(`${key}-result`);
                const statusEl = document.getElementById(`${key}-status`);
                
                if (res && res.status && res.status.startsWith('Converged')) {
                    resultEl.textContent = res.root.toFixed(7);
                    statusEl.textContent = res.status;
                    statusEl.className = 'status converged';
                    
                    const iterations = parseInt(res.status.match(/\d+/)?.[0] || Infinity);
                    if (iterations < bestIterations) {
                        bestIterations = iterations;
                        bestMethod = key;
                    }
                } else {
                    resultEl.textContent = '-';
                    statusEl.textContent = res ? res.status : 'Error';
                    statusEl.className = 'status failed';
                }
            });
            
            if (bestMethod) {
                const methodName = bestMethod.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase());
                DOM.bestMethod.textContent = `✨ ${methodName} converged fastest in ${bestIterations} iterations. ` +
                    `Newton typically shows quadratic convergence, while Bisection has linear convergence but guaranteed success.`;
                DOM.convergenceSummary.style.display = 'block';
            }
        }
        
        function drawErrorPlot() {
            if (!analysisResults) return;
            
            DOM.plotContainer.innerHTML = '<canvas id="error-chart-canvas"></canvas>';
            const canvas = document.getElementById('error-chart-canvas');
            
            if (errorChart) {
                errorChart.destroy();
            }
            
            const datasets = Object.keys(analysisResults).map(key => ({
                label: key.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase()),
                data: analysisResults[key].errors,
                borderColor: getMethodColor(key),
                backgroundColor: getMethodColor(key) + '20',
                tension: 0.1,
                fill: false,
                pointRadius: 3,
                pointHoverRadius: 5
            })).filter(ds => ds.data);
            
            errorChart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels: Array.from({length: 31}, (_, i) => i),
                    datasets: datasets
                },
                options: getChartOptions()
            });
        }
        
        function getMethodColor(method) {
            const colors = {
                'bisection': '#f59e0b',
                'false-pos': '#dc2626',
                'secant': '#8b5cf6',
                'newton': '#10b981',
                'fixed-point': '#3b82f6'
            };
            return colors[method] || '#666';
        }
        
        function getChartOptions() {
            return {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Iteration Number',
                            font: { size: 14 }
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.05)'
                        }
                    },
                    y: {
                        type: 'logarithmic',
                        title: {
                            display: true,
                            text: 'log |Error|',
                            font: { size: 14 }
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.05)'
                        },
                        ticks: {
                            callback: function(value) {
                                if (value === 1e-16) return '10⁻¹⁶';
                                if (value === 1e-12) return '10⁻¹²';
                                if (value === 1e-8) return '10⁻⁸';
                                if (value === 1e-4) return '10⁻⁴';
                                if (value === 1) return '10⁰';
                                return '';
                            }
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: { size: 12 }
                        }
                    },
                    tooltip: {
                        mode: 'index',
                        intersect: false,
                        backgroundColor: 'rgba(255,255,255,0.9)',
                        titleColor: '#212121',
                        bodyColor: '#4b5563',
                        borderColor: '#e5e7eb',
                        borderWidth: 1,
                        padding: 12,
                        displayColors: true
                    }
                }
            };
        }
        
        // Tab switching function - global
        function switchTab(tabName) {
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target?.classList.add('active') || 
            document.querySelector(`[onclick="switchTab('${tabName}')"]`).classList.add('active');
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }
        
        // Reset function - make it global
        function resetCustom() {
            // Clear all input fields
            document.getElementById('custom-function-input').value = '';
            document.getElementById('custom-g-input').value = '';
            document.getElementById('a-input').value = '-2';
            document.getElementById('b-input').value = '3';
            document.getElementById('x0-input').value = '0';
            document.getElementById('x1-input').value = '1';
            
            // Hide results and AI assistant
            const customResults = document.getElementById('custom-results');
            const aiAssistant = document.getElementById('ai-assistant');
            if (customResults) customResults.style.display = 'none';
            if (aiAssistant) aiAssistant.style.display = 'none';
            
            // Clear displays
            const fDisplay = document.getElementById('custom-f-display');
            const gDisplay = document.getElementById('custom-g-display');
            if (fDisplay) fDisplay.innerHTML = '<span style="color: #9e9e9e;">Enter a function above</span>';
            if (gDisplay) gDisplay.innerHTML = '<span style="color: #9e9e9e;">AI will suggest or enter manually</span>';
            
            // Clear graph
            const canvas = document.getElementById('function-graph');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#9e9e9e';
                ctx.font = '14px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('Enter a function to see the graph', canvas.width / 2, canvas.height / 2);
            }
        }
        
        // Make functions globally accessible
        window.switchTab = switchTab;
        window.resetCustom = resetCustom;
        
        // Demo functions (simplified from original)
        function initializeDemo() {
            const canvas = document.getElementById('demo-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = 300;
            drawDemoFunction();
        }
        
        function drawDemoFunction() {
            const canvas = document.getElementById('demo-canvas');
            const ctx = canvas.getContext('2d');
            const funcStr = DOM.demoFunction.value;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const padding = 40;
            const xMin = -4, xMax = 4;
            const yMin = -3, yMax = 5;
            
            function toCanvasX(x) {
                return padding + (x - xMin) / (xMax - xMin) * (canvas.width - 2 * padding);
            }
            
            function toCanvasY(y) {
                return canvas.height - padding - (y - yMin) / (yMax - yMin) * (canvas.height - 2 * padding);
            }
            
            // Draw axes
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(toCanvasX(xMin), toCanvasY(0));
            ctx.lineTo(toCanvasX(xMax), toCanvasY(0));
            ctx.moveTo(toCanvasX(0), toCanvasY(yMin));
            ctx.lineTo(toCanvasX(0), toCanvasY(yMax));
            ctx.stroke();
            
            // Draw function
            try {
                const func = math.compile(funcStr);
                ctx.strokeStyle = '#0f766e';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let px = 0; px < canvas.width; px++) {
                    const x = xMin + (px / canvas.width) * (xMax - xMin);
                    const y = func.evaluate({x: x});
                    
                    if (px === 0) {
                        ctx.moveTo(toCanvasX(x), toCanvasY(y));
                    } else {
                        ctx.lineTo(toCanvasX(x), toCanvasY(y));
                    }
                }
                ctx.stroke();
            } catch (e) {}
        }
        
        function startDemoAnimation() {
            if (demoAnimation) {
                clearInterval(demoAnimation);
                demoAnimation = null;
                DOM.demoStart.textContent = 'Start Animation';
                return;
            }
            
            DOM.demoStart.textContent = 'Stop Animation';
            
            const funcStr = DOM.demoFunction.value;
            const x0 = parseFloat(DOM.demoX0.value);
            const speed = parseInt(DOM.demoSpeed.value);
            
            let func, derivative;
            try {
                func = math.compile(funcStr);
                derivative = math.derivative(funcStr, 'x').compile();
            } catch (e) {
                alert('Error compiling function');
                return;
            }
            
            let currentX = x0;
            let iteration = 0;
            const maxIterations = 10;
            let trueRoot = findTrueRoot(func, derivative, x0);
            
            demoAnimation = setInterval(() => {
                const fx = func.evaluate({x: currentX});
                const fpx = derivative.evaluate({x: currentX});
                
                if (Math.abs(fpx) < 1e-10 || iteration >= maxIterations) {
                    clearInterval(demoAnimation);
                    demoAnimation = null;
                    DOM.demoStart.textContent = 'Start Animation';
                    return;
                }
                
                const nextX = currentX - fx / fpx;
                
                DOM.demoIteration.textContent = iteration;
                DOM.demoCurrentX.textContent = currentX.toFixed(6);
                DOM.demoFx.textContent = fx.toFixed(6);
                DOM.demoError.textContent = Math.abs(currentX - trueRoot).toExponential(2);
                
                drawNewtonStep(funcStr, currentX, nextX);
                
                currentX = nextX;
                iteration++;
                
                if (Math.abs(fx) < 1e-10) {
                    clearInterval(demoAnimation);
                    demoAnimation = null;
                    DOM.demoStart.textContent = 'Start Animation';
                }
            }, speed);
        }
        
        function findTrueRoot(func, derivative, x0) {
            let x = x0;
            for (let i = 0; i < 100; i++) {
                const fx = func.evaluate({x: x});
                const fpx = derivative.evaluate({x: x});
                if (Math.abs(fpx) < 1e-14) return x;
                const xNew = x - fx / fpx;
                if (Math.abs(xNew - x) < 1e-15) return xNew;
                x = xNew;
            }
            return x;
        }
        
        function drawNewtonStep(funcStr, x0, x1) {
            const canvas = document.getElementById('demo-canvas');
            const ctx = canvas.getContext('2d');
            
            drawDemoFunction();
            
            const padding = 40;
            const xMin = -4, xMax = 4;
            const yMin = -3, yMax = 5;
            
            function toCanvasX(x) {
                return padding + (x - xMin) / (xMax - xMin) * (canvas.width - 2 * padding);
            }
            
            function toCanvasY(y) {
                return canvas.height - padding - (y - yMin) / (yMax - yMin) * (canvas.height - 2 * padding);
            }
            
            try {
                const func = math.compile(funcStr);
                const derivative = math.derivative(funcStr, 'x').compile();
                
                const fx0 = func.evaluate({x: x0});
                const fpx0 = derivative.evaluate({x: x0});
                
                // Draw tangent line
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                
                const tangentY1 = fx0 + fpx0 * (xMin - x0);
                const tangentY2 = fx0 + fpx0 * (xMax - x0);
                
                ctx.moveTo(toCanvasX(xMin), toCanvasY(tangentY1));
                ctx.lineTo(toCanvasX(xMax), toCanvasY(tangentY2));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw current point
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(toCanvasX(x0), toCanvasY(fx0), 5, 0, 2 * Math.PI);
                ctx.fill();
                
                // Draw next point
                ctx.fillStyle = '#10b981';
                ctx.beginPath();
                ctx.arc(toCanvasX(x1), toCanvasY(0), 5, 0, 2 * Math.PI);
                ctx.fill();
            } catch (e) {}
        }
    </script>
</body>
</html>
